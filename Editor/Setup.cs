using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using UnityEditor;
using UnityEngine;
using UnityEditor.PackageManager;
using UnityEditor.PackageManager.Requests;
using static System.IO.Directory;
using Debug = UnityEngine.Debug;

namespace MyTools {
    /// <summary>
    /// Provides setup utilities for Unity projects, including folder creation, package installation, 
    /// and Git repository initialization.
    /// </summary>
    public static class Setup {
        /// <summary>
        /// Creates a set of default folders for organizing Unity project assets.
        /// </summary>
        [MenuItem("Tools/Setup/Create Default Folders")]
        public static void CreateDefaultFolders() {
            // Create main project folders
            Folders.Create("_Project", "Animations",
                "Art",
                "Materials",
                "ScriptableObjects",
                "_Scripts",
                "Prefabs"
            );
            Folders.Create("External");
            Folders.Create("Plugins");
            AssetDatabase.Refresh();

            // Move specific folders into the _Project folder
            Folders.Move("_Project", "Scenes");
            Folders.Move("_Project", "Settings");

            // Delete unnecessary folders
            Folders.Delete("TutorialInfo");
            AssetDatabase.Refresh();

            // Move Input System actions file to the Settings folder
            const string pathToInputActions = "Assets/InputSystem_Actions.inputactions";
            const string destination = "Assets/_Project/Settings/InputSystem_Actions.inputactions";
            AssetDatabase.MoveAsset(pathToInputActions, destination);

            // Delete the Readme asset
            const string pathToReadme = "Assets/Readme.asset";
            AssetDatabase.DeleteAsset(pathToReadme);
            AssetDatabase.Refresh();
        }

        /// <summary>
        /// Installs a list of open-source Unity packages using their Git URLs.
        /// </summary>
        [MenuItem("Tools/Setup/Install My Favorite Open Source")]
        public static void InstallOpenSource() {
            Packages.InstallPackages(new[] {
                "git+https://github.com/KyleBanks/scene-ref-attribute",
                "git+https://github.com/UnityCommunity/UnitySingleton.git",
                "git+https://github.com/starikcetin/Eflatun.SceneReference.git#4.1.1",
                "git+https://github.com/adammyhre/Unity-Improved-Timers.git",
                "git+https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask",
                "com.unity.probuilder"
                // Add more
            });
        }

        /// <summary>
        /// Initializes a Git repository in the Unity project directory and creates a .gitignore file.
        /// </summary>
        [MenuItem("Tools/Setup/Initialize Github Repository")]
        public static void InitializeGitRepo() {
            // Define the content of the .gitignore file
            const string gitIgnoreContent = @"### Processing ###
.DS_Store
applet
application.linux-arm64
application.linux-armv6hf
application.linux32
application.linux64
application.windows32
application.windows64
application.macosx
out

### Unity ###
# This .gitignore file should be placed at the root of your Unity project directory
#
# Get latest from https://github.com/github/gitignore/blob/main/Unity.gitignore
Assets/*
# Exclude _Project folder and its .meta
!Assets/_Project/
!Assets/_Project.meta
# Exclude External folder and its .meta
!Assets/External/
!Assets/External.meta
# Exclude Plugins folder and its .meta
!Assets/Plugins/
!Assets/Plugins.meta
/[Ll]ibrary/
/[Tt]emp/
/[Oo]bj/
/[Bb]uild/
/[Bb]uilds/
/[Ll]ogs/
/[Uu]ser[Ss]ettings/

# MemoryCaptures can get excessive in size.
# They also could contain extremely sensitive data
/[Mm]emoryCaptures/

# Recordings can get excessive in size
/[Rr]ecordings/

# Uncomment this line if you wish to ignore the asset store tools plugin
# /[Aa]ssets/AssetStoreTools*

# Autogenerated Jetbrains Rider plugin
/[Aa]ssets/Plugins/Editor/JetBrains*

# Visual Studio cache directory
.vs/

# Gradle cache directory
.gradle/

# Autogenerated VS/MD/Consulo solution and project files
ExportedObj/
.consulo/
*.csproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd
*.pdb
*.mdb
*.opendb
*.VC.db

# Unity3D generated meta files
*.pidb.meta
*.pdb.meta
*.mdb.meta

# Unity3D generated file on crash reports
sysinfo.txt

# Builds
*.apk
*.aab
*.unitypackage
*.app

# Crashlytics generated file
crashlytics-build.properties

# Packed Addressables
/[Aa]ssets/[Aa]ddressable[Aa]ssets[Dd]ata/*/*.bin*

# Temporary auto-generated Android Assets
/[Aa]ssets/[Ss]treamingAssets/aa.meta
/[Aa]ssets/[Ss]treamingAssets/aa/*
";
            // Write the .gitignore file to the project root
            File.WriteAllText(Application.dataPath + "/../.gitignore", gitIgnoreContent);

            // Initialize a Git repository
            try {
                var process = Process.Start("git", "init");
                process?.WaitForExit();
                if (process?.ExitCode != 0) {
                    Debug.LogError($"Git init failed with exit code: {process?.ExitCode}");
                }
            }
            catch (Exception e) {
                Debug.LogError("Failed to initialize Git repository: " + e.Message);
            }
        }

        /// <summary>
        /// Provides utility methods for folder operations such as creation, deletion, and moving.
        /// </summary>
        private static class Folders {
            /// <summary>
            /// Deletes a folder in the Unity project if it exists.
            /// </summary>
            /// <param name="folderName">The name of the folder to delete.</param>
            public static void Delete(string folderName) {
                var pathToDelete = $"Assets/{folderName}";
                if (AssetDatabase.IsValidFolder(pathToDelete)) {
                    AssetDatabase.DeleteAsset(pathToDelete);
                }
            }

            /// <summary>
            /// Moves a folder to a new parent folder within the Unity project.
            /// </summary>
            /// <param name="newParent">The name of the new parent folder.</param>
            /// <param name="folderName">The name of the folder to move.</param>
            public static void Move(string newParent, string folderName) {
                var sourcePath = $"Assets/{folderName}";
                if (AssetDatabase.IsValidFolder(sourcePath)) {
                    var destinationPath = $"Assets/{newParent}/{folderName}";
                    var error = AssetDatabase.MoveAsset(sourcePath, destinationPath);
                    if (!string.IsNullOrEmpty(error)) {
                        Debug.LogError($"Failed to move {folderName}: {error}");
                    }
                }
                else {
                    Debug.Log("Folder does not exist: " + sourcePath);
                }
            }

            /// <summary>
            /// Creates a root folder and any number of subfolders within it.
            /// </summary>
            /// <param name="root">The name of the root folder.</param>
            /// <param name="folders">The names of the subfolders to create.</param>
            public static void Create(string root, params string[] folders) {
                var fullPath = Path.Combine(Application.dataPath, root);
                if (!Exists(fullPath)) {
                    CreateDirectory(fullPath);
                }
                foreach (var folder in folders) {
                    var path = Path.Combine(fullPath, folder);
                    if (!Exists(path)) {
                        CreateDirectory(path);
                    }
                }
            }
        }

        /// <summary>
        /// Provides utility methods for installing Unity packages.
        /// </summary>
        private static class Packages {
            // Key to store our package queue in the editor's session state
            private const string PackagesToInstallKey = "MyTools.PackagesToInstall";
            private static AddRequest _currentRequest;

            /// <summary>
            /// This method is called automatically by Unity whenever scripts are loaded.
            /// It acts as a recovery mechanism to continue installations after a script reload.
            /// </summary>
            [InitializeOnLoadMethod]
            private static void InitializeAndContinue() {
                // Using delayCall ensures that we wait until the editor is ready before proceeding.
                EditorApplication.delayCall += ContinueInstallation;
            }

            /// <summary>
            /// Installs a list of Unity packages.
            /// </summary>
            /// <param name="packages">An array of package identifiers (names or git URLs) to install.</param>
            public static void InstallPackages(IEnumerable<string> packages) {
                var packageList = packages.ToList();
                if (!packageList.Any()) {
                    Debug.Log("No packages to install.");
                    return;
                }

                // Store the full list of packages in SessionState, using a semicolon as a separator.
                // This list will persist across script reloads.
                SessionState.SetString(PackagesToInstallKey, string.Join(";", packageList));

                // Start the installation process.
                ContinueInstallation();
            }

            /// <summary>
            /// Continues the installation process by processing the next package in the queue.
            /// </summary>
            private static void ContinueInstallation() {
                // Don't start a new installation if one is already in progress.
                if (_currentRequest != null && !_currentRequest.IsCompleted) {
                    return;
                }

                // Retrieve the list of packages from SessionState.
                var queueData = SessionState.GetString(PackagesToInstallKey, "");
                if (string.IsNullOrEmpty(queueData)) {
                    // If the queue is empty, we are done.
                    return;
                }
                var packagesToInstall = new Queue<string>(queueData.Split(';'));
                if (packagesToInstall.Count > 0) {
                    // Get the next package to install.
                    var packageName = packagesToInstall.Dequeue();

                    // Update the session state with the remaining packages.
                    SessionState.SetString(PackagesToInstallKey, string.Join(";", packagesToInstall));
                    Debug.Log($"Requesting package: {packageName}...");
                    _currentRequest = Client.Add(packageName);

                    // Subscribe to the editor's update loop to monitor the request's progress.
                    EditorApplication.update += Progress;
                }
                else {
                    // All packages are installed, clear the key from SessionState.
                    Debug.Log("All packages installed successfully.");
                    SessionState.EraseString(PackagesToInstallKey);
                }
            }

            /// <summary>
            /// Monitors the progress of the current package installation request.
            /// </summary>
            private static void Progress() {
                // Wait until the current request is completed.
                if (_currentRequest.IsCompleted) {
                    if (_currentRequest.Status == StatusCode.Success) {
                        Debug.Log($"Installed: {_currentRequest.Result.displayName}");
                    }
                    else if (_currentRequest.Status >= StatusCode.Failure) {
                        Debug.LogError($"Failed to install package: {_currentRequest.Error.message}");
                    }

                    // Unsubscribe from the update loop to stop checking.
                    EditorApplication.update -= Progress;

                    // Use delayCall to trigger the next installation. This is safer than a direct call.
                    EditorApplication.delayCall += ContinueInstallation;
                }
            }
        }
    }
}